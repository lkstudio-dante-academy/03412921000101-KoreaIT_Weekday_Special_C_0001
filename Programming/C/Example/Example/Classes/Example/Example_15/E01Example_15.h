#pragma once

#include "../../Global/Define/KDefine+Global.h"

/*
* 포인터 (Pointer) 란?
* - 메모리 주소를 제어 할 수 있는 기능을 의미한다. (+ 즉, 포인터를 활용하면 메모리 주소를 기반으로
* 다양한 연산을 처리하는 것이 가능하다.)
* 
* C 는 포인터를 통해 메모리를 자유롭게 제어하는 것이 가능하지만 포인터를 통해 특정 메모리를
* 제어하기 위해서는 사전에 메모리에 대한 사용 권한을 획득 할 필요가 있다. (+ 즉, 
* 권한이 없는 메모리에 접근을 시도하면 프로그램이 오작동 한다는 것을 알 수 있다.)
* 
* C 에서 메모리에 대한 사용 권한을 획득하는 방법 중 하나는 변수를 선언하는 것이다. (+ 즉, 변수는
* 데이터를 저장하거나 읽어들일 수 있는 공간을 메모리에 할당하는 것이기 때문에
* 변수를 선언하는 것은 특정 메모리에 대한 사용 권한을 획득하는 것을 전제로 이루어진다는 것을
* 알 수 있다.)
* 
* 따라서 포인터는 단독으로 사용이 불가능하며 포인터를 사용하기 전에 반드시 변수 선언 등을 활용해서
* 메모리에 대한 사용 권한을 획득해야한다.
* 
* C 포인터 변수 선언 방법
* - 자료형 + 포인터 연산자 + 포인터 변수 이름
* 
* Ex)
* int nVal = 0;
* int* pnVal = &nVal;
* 
* 위와 같이 * (포인터 연산자) 를 통해 포인터 변수를 선언하는 것이 가능하다.
* 
* 포인터 변수에는 일반적인 데이터가 아닌 메모리 주소만을 할당하는 것이 가능하며 메모리 주소는
* 변수 이름 앞에 & (주소 연산자) 를 명시하는 것으로 특정 변수가 할당 된 메모리 주소를 가져오는 것이
* 가능하다.
* 
* 포인터 변수에 메모리 주소가 할당 되면 해당 메모리에 접근해서 데이터를 저장하거나 읽어들이는 것이
* 가능하다. (+ 즉, 변수의 이름을 통하지 않고 변수를 제어하는 것이 가능하다는 것을 의미한다.)
* 
* Ex)
* *pnVal = 10;
* 
* 위와 같이 포인터 변수 앞에 * (역참조 연산자) 를 명시하면 포인터 변수에 저장 된 메모리 주소를
* 통해 해당 메모리에 접근하는 것이 가능하다. (+ 즉, 메모리 주소를 통해 해당 메모리에
* 접근하고 싶다면 * (역참조 연산자) 를 활용하면 된다는 것을 알 수 있다.)
*/

/** Example 15 */
int E01Example_15(int argc, char* args[]);
