#pragma once

#include "../../../Classes/Global/Define/KDefine+Global.h"

/*
* 자료형 (Data Type) 이란?
* - 데이터를 해석하는 방법을 의미한다. (+ 즉, 동일한 형태의 데이터라고 하더라도 자료형에 따라
* 처리 방식이 달라진다는 것을 알 수 있다.)
*
* 또한 자료형은 데이터가 표현 할 수 있는 최대 범위를 제한하는 역할을 수행한다. (+ 즉, 자료형마다
* 데이터의 최대 표현 범위가 다르다는 것을 알 수 있다.)
*
* C 자료형 종류 - 정수 (Integer)
* - short : 2 Byte
* - int : 4 Byte
* - long : 4 Byte or 8 Byte
* - long long : 8 Byte
*
* C 자료형 종류 - 실수 (Floating Point)
* - float : 4 Byte
* - double : 8 Byte
*
* C 자료형 종류 - 문자
* - char : 1 Byte
*
* 위와 같이 C 는 다양한 자료형을 지원하며 해당 자료형을 이용해서 목적에 맞게
* 데이터를 처리하는 것이 가능하다.
*
* 또한 C 와 같은 프로그래밍 언어에서 데이터의 최소 단위는 일반적으로 바이트를 사용한다. (+ 즉,
* 비트 단위로 데이터를 처리하는 것도 가능하지만 프로그래밍 언어에서는 일반적으로 바이트 단위로
* 데이터를 처리 한다는 것을 알 수 있다.)
*
* 정수 (Integer) vs 실수 (Floating Point)
* - 정수는 실수에 비해서 연산 속도가 빠르고 수를 정확하게 표현하는 것이 가능하지만
* 소수점을 표현하는 것이 불가능하다는 단점이 존재한다.
*
* 반면 실수는 소수점이 존재하는 수를 표현하는 것이 가능하지만
* 정수에 비해 연산 속도와 정밀도가 떨어지는 단점이 존재한다. (+ 즉, 실수는 특정 수를 정확하게
* 표현하는 것이 불가능하다는 것을 알 수 있다.)
*
* 이는 소수점이 존재하는 수를 정확하게 표현하기 위해서는 많은 데이터 (비트) 가 필요하기 때문에
* 대부분의 컴퓨터는 소수점이 존재하는 수를 표현하기 위해서 부동 소수점 방식을 사용하기 때문이다.
*
* 부동 소수점 방식은 적은 데이터 (비트) 를 가지고도 넓은 범위의 수를 표현하기 위해서 특별한 공식을
* 활용하며 해당 공식에 의해 오차가 발생 한다는 것을 알 수 있다. (+ 즉, 부동 소수점 방식은 비트를
* 바로 수로 변환하는 것이 아니라 공식을 통해 산출 된 결과를 통해 수를 표현하기 때문에 정수에 비해서
* 처리 속도가 떨어진다는 것을 알 수 있다.)
*
* 부호 있음 (Signed) vs 부호 없음 (Unsigned)
* - 컴퓨터는 양수와 음수를 구분하기 위해서 부호 비트를 요구하며 해당 비트는 데이터를 표현하는
* 비트의 가장 왼쪽에 존재하는 비트를 사용한다. (즉, 부호 비트가 0 일 경우 양수를 의미하며
* 1 일 경우 음수를 의미한다.)
*
* Signed 는 부호 비트를 사용하기 때문에 양수와 음수를 모두 표현하는 것이 가능하지만
* 최대 표현 할 수 있는 양수의 범위가 절반으로 줄어드는 단점이 존재한다.
*
* 반면 Unsigned 는 부호 비트 또한 데이터를 표현하는데 사용하기 때문에 Signed 에 비해서
* 표현 할 수 있는 양수의 범위가 2 배 증가하지만 음수를 표현하는 것이 불가능하다. (즉, 부호 비트를
* 양수 or 음수를 표현하는데 사용하지 않고 수의 범위를 표현하는데 사용한다는 것을 알 수 있다.)
*
* C 은 signed or unsigned 키워드를 정수형 자료형 앞에 명시함으로서
* 부호 있는 정수 or 부호 없는 정수를 선언하는 것이 가능하다.
*
* 변수 (Variable) 란?
* - 데이터를 저장 하거나 읽어들일 수 있는 공간을 의미한다. (+ 즉, 변수를 활용하면
* 특정 데이터를 저장 후 필요 할 때 재사용하는 것이 가능하다.)
*
* 변수는 메모리 (주 기억 장치) 에 위치하기 때문에 변수에 접근하기 위한 수단이 필요하며
* 이때 활용되는 것이 변수의 이름이다. (+ 즉, 변수 이름을 통해 특정 변수를 제어하는 것이 가능하다.)
*
* C 변수 선언 방법
* - 자료형 + 변수 이름
*
* Ex)
* int nVal = 0;
* float fVal = 0.0f;
*
* 상수 (Constant) 란?
* - 데이터를 저장 하거나 읽어들일 수 있는 공간을 의미한다. (+ 즉, 변수와 유사하다는 것을
* 알 수 있다.)
*
* 단, 데이터를 자유롭게 변경 할 수 있는 변수와 달리 상수는 한번 데이터가 저장되고 나면
* 이 후 더이상 데이터를 변경하는 것은 불가능하며 읽어들이는 것만 가능하다는 차이점이 존재한다.
*
* 따라서 상수에는 데이터를 저장하는 시점이 중요하며 해당 시점은 상수를 선언과 동시에 초기화하는
* 단계이다. (+ 즉, 상수를 선언과 동시에 데이터를 할당하는 것으로 특정 상수에 데이터를 저장하는 것이
* 가능하다.)
*
* C 상수 종류
* - 리터널 상수 (Literal Constant)			<- 이름이 없는 상수 (+ Ex. 'A', 10 등등...)
* - 심볼릭 상수 (Symbolic Constant)			<- 이름이 존재하는 상수
*
* C 리터널 상수 관련 접미어
* - l or L			<- long or long double
* - ll or LL		<- long long
* - f or F			<- float
*
* Ex)
* int nValA = 10;
* long nValB = 20L;
* long long nValC = 30LL;
*
* 위의 경우 정수 상수는 기본 자료형이 int 이기 때문에 long 자료형 상수 인 것을 알리기 위해
* 숫자 뒤에 L 접미어를 명시해줘야한다.
*
* 마찬가지로 LL 접미어를 명시하면 long long 자료형 상수라는 것을 알 수 있다.
*
* float fVal = 10.0f;
* double dblVal = 20.0;
* long doubl ldblVal = 30.0L;
*
* 위의 경우 실수 상수는 기본 자료형이 double 이기 때문에 float 자료형 상수 인 것을 알리기 위해
* 숫자 뒤에 f 접미어를 명시해줘야한다.
*
* 마찬가지로 L 접미어를 명시하면 long double 자료형 상수라는 것을 알 수 있다.
*
* C 심볼릭 상수 선언 방법
* - const + 자료형 + 상수 이름
*
* Ex)
* const int nVal = 0;
* const float fVal = 0.0f;
*
* 위와 같이 상수를 선언하고 나면 이후 해당 상수에 저장 된 데이터를 변경하는 것은 불가능하다. (+ 즉,
* 상수 선언 이후에 데이터를 할당하면 컴파일 에러가 발생 한다는 것을 의미한다.)
*
* C 이름 작성 규칙
* - C 에서 이름에 사용 할 수 있는 문자 종류는 알파벳 대/소문자, _ (언더 스코어), 숫자 만을
* 사용하다.
*
* C 은 알파벳 대/소문자, _ (언더 스코어), 숫자를 조합해서 자유롭게 이름을 작성하는 것이
* 가능하지만 첫 문자는 숫자가 될 수 없다. (+ 즉, 이름의 첫 문자를 숫자로 명시 할 경우
* 컴파일 에러가 발생 한다는 것을 알 수 있다.)
*
* 또한 이름은 대/소문자를 구분하기 때문에 같은 단어라 하더라도 대/소문자 조합이 다르면
* 서로 다른 이름으로 구분 된다.
*
* Ex)
* int nval = 0;
* int nVal = 0;
*
* 위의 경우 nval 변수와 nVal 변수는 동일한 단어지만 V 문자가 서로 다르기 때문에
* 서로 다른 변수라는 것을 알 수 있다. (+ 즉, 대/소문자를 구별 한다는 것을 알 수 있다.)
*
* int nVal_01 = 0;
* int 01_nVal = 0;			<- 컴파일 에러
*
* 위의 경우 nVal_01 변수와 01_nVal 변수는 변수 이름에 숫자가 들어갔지만 nVal_01 변수는
* 첫 문자가 숫자가 아니기 때문에 정상적으로 동작하는 반면 01_nVal 변수는 첫 이름이 숫자이기 때문에
* 컴파일 에러가 발생 한다는 것을 알 수 있다.
*/

/** Example 2 */
int E01Example_02(int argc, char* args[]);
