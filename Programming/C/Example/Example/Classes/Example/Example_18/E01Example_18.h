#pragma once

#include "../../Global/Define/KDefine+Global.h"

/*
* 포인터 연산 (Pointer Operation) 이란?
* - 포인터 (메모리 주소) 를 대상으로 연산을 하는 것을 의미하며 포인터는 + 와 - 연산자를 통해
* 연산을 하는 것이 가능하다.
* 
* 포인터 연산을 할 경우 포인터가 현재 참조하고 있는 메모리 주소를 변경 할 수 있다. (+ 즉,
* 포인터 연산을 활용하면 특정 메모리에 접근하는 것이 가능하다.)
* 
* Ex)
* int nVal = 0;
* int* pnVal = &nVal;					<- Ex. 0x10 메모리 주소 할당
* 
* printf("%p\n", pnVal + 1);			<- 0x14 출력
* 
* 위와 같이 포인터는 + 와 - 연산자를 사용하는 것이 가능하며 포인터에 해당 연산자를 사용함으로서
* 현재 참조하는 메모리 주소를 변경하는 것이 가능하다.
* 
* 단, 포인터 연산에 사용 되는 숫자는 간격의 의미이며 간격은 포인터의 자료형에 따라 다르다. (+ 즉,
* char 형 포인터 일 경우 간격은 1 바이트를 의미하며 int 형 포인터 일 경우 간격은 4 바이트를
* 의미한다.)
* 
* 배열과 포인터의 관계
* - 배열의 이름에는 배열의 첫번째 요소를 참조하는 메모리 주소가 할당 되어 있으며 내부적으로
* 포인터 연산을 활용해서 특정 위치에 존재하는 요소에 접근한다. (+ 즉, 배열의 동작은
* 포인터 연산을 통해 이루어진다는 것을 알 수 있다.)
* 
* 배열은 2 번째 상수 포인터 유형과 유사하기 때문에 포인터 연산과 역참조 연산자를 직접적으로
* 사용하는 것도 가능하다. (+ 즉, 2 번째 상수 포인터와 유사한 특징을 지니고 있기 때문에 배열에
* 다른 데이터를 할당하는 것이 불가능하다는 것을 알 수 있다.)
* 
* Ex)
* int anValues[5] = { 0 };
* *(anValues + 0) = 10;			<- anValues[0] 와 동일한 의미
* 
* 위와 같이 포인터 연산과 역참조를 이용해서 배열을 포인터처럼 제어하는 것이 가능하다. (+ 즉,
* 반대로 포인터를 배열처럼 제어하는 것도 가능하다는 것을 알 수 있다.)
*/

/** Example 18 */
int E01Example_18(int argc, char* args[]);
