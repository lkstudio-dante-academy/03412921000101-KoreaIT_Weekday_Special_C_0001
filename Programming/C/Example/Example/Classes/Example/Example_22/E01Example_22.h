#pragma once

#include "../../Global/Define/KDefine+Global.h"

/*
* 사용자 정의 자료형 (User Defined Data Type) 이란?
* - C 에서 기본적으로 제공 되는 자료형 이외에 사용자 (프로그래머) 가 필요에 따라 직접 정의해서
* 사용하는 자료형을 의미한다. (+ 즉, 사용자 정의 자료형을 활용하면 제작하는 프로그램에 적합한
* 자료형을 정의하는 것이 가능하다.)
*
* 단, 사용자 정의 자료형은 C 에서 존재하지 않는 자료형을 새롭게 정의하는 것이 아니라
* C 에서 제공하는 기본 자료형을 활용해서 새로우 자료형을 정의하는 것이다. (+ 즉,
* 사용자 정의 자료형은 C 에서 제공되는 기본 자료형을 활용해서 정의 한다는 것을 알 수 있다.)
*
* C 사용자 정의 자료형 종류
* - 구조체
* - 공용체
* - 열거형
*
* 구조체 (Structure) 란?
* - 여러 자료형을 하나의 그룹으로 묶어서 관리 할 수 있는 기능을 의미한다. (+ 즉, 구조체를 활용하면
* 연관 된 데이터를 하나의 자료형으로 제어하는 것이 가능하다.)
*
* C 구조체 정의 방법
* - struct + 구조체 이름 + 구조체 멤버
*
* Ex)
* struct STSomeStruct
* {
*		int m_nVal;
*		float m_fVal;
* };
*
* struct STSomeStruct stStructVar;
* stStructVar.m_nVal = 10;
*
* 위와 같이 struct 키워드를 활용하면 구조체를 정의하는 것이 가능하며 정의 된 구조체는 자료형처럼
* 활용하는 것이 가능하다. (+ 즉, 구조체를 통해 변수를 선언 할 수 있으며 해당 변수를 구조체 변수라고
* 한다.)
*
* 구조체 변수 내부에는 구조체에서 정의 한 멤버들이 존재하며 해당 멤버들에 접근하기 위해서는
* . (멤버 지정 연산자) 를 활용하면 된다. (+ 즉, 멤버 지정 연산자를 활용하면 구조체 변수 내부에
* 존재하는 멤버를 제어하는 것이 가능하다.)
*
* 구조체는 사용자 정의 자료형이기 때문에 구조체를 자료형으로 사용 할려면 반드시 struct 키워드를
* 명시해줘야한다. (+ 즉, struct 키워드를 명시해서 해당 자료형이 구조체라는 것을 C 컴파일러에게
* 알려야한다는 것을 알 수 있다.)
*
* 따라서 일반적으로 구조체를 정의 할 때는 struct 키워드를 생략하고 구조체를 자료형으로
* 사용 할 수 있도록 typedef 키워드를 통해 새로운 이름을 추가하는 것이 정형화 된 구조이다.
*
* Ex)
* typedef struct STSomeStruct
* {
*		int m_nVal;
*		float m_fVal;
* } STSomeStruct;
*
* STSomeStruct stSomeStruct;
* stSomeStruct.m_nVal = 10;
*
* 위와 같이 typedef 키워드를 활용해서 구조체를 정의하면 struct 키워드를 명시하지 않고
* 구조체를 자료형으로 사용하는 것이 가능하다.
*
* 공용체 (Union) 란?
* - 여러 자료형을 하나의 그룹으로 묶어서 관리 할 수 있는 기능을 의미한다. (+ 즉, 공용체를 활용하면
* 구조체와 마찬가지로 연관 된 데이터를 하나의 자료형으로 제어하는 것이 가능하다.)
*
* C 공용체 정의 방법
* - union + 공용체 이름 + 공용체 멤버
*
* Ex)
* union UNSomeUnion
* {
*		int m_nVal;
*		float m_fVal;
* };
*
* union UNSomeUnion unUnionVar;
* unUnionVar.m_nVal = 10;
* 
* 위와 같이 정의 된 공용체는 자료형으로 사용하는 것이 가능하다. (+ 즉, 공용체를 사용해 변수 선언이
* 가능하며 이러한 변수를 공용체 변수라고 한다.)
* 
* 단, 공용체는 구조체와 달리 모든 멤버가 동일한 메모리 공간을 공유하는 특징이 있다. (+ 즉, 
* 구조체는 멤버마다 개별적으로 메모리에 할당 되지만 공용체는 모두 같은 메모리에 멤버가 할당 된다는
* 것을 알 수 있다.)
* 
* 따라서 공용체 변수에는 가장 마지막에 할당 된 멤버의 데이터만 유효하다는 것을 알 수 있다. (+ 즉,
* 멤버에 데이터를 할당함으로서 다른 멤버의 데이터가 망가질 수 있다는 것을 의미한다.)
*/

/** Example 22 */
int E01Example_22(int argc, char* args[]);
